# 总体实现思路

## 背景

大文件的上传，如果不作特殊处理，将遇到以下问题：

1. **网络中断导致上传失败**: 网络中断、程序异常退出等问题导致文件上传失败，从而不得不全部重新上传
2. **重复文件占用资源**: 同一文件被不同用户反复上传，白白占用网络和服务器存储资源

因此，需要一个针对大文件上传的方案来解决上述问题。

## 解决方案：文件分片上传

大文件上传的普遍方案是**文件分片上传**。

如果把文件上传看做是一个不可分割的事务，那么分片的目标就是把一个耗时的大事务划分为一个一个的小事务。

分片上传需要解决两个核心问题：

1. **如何减少页面阻塞**
2. **前后端如何协调**

## 问题 1: 如何减少页面阻塞？

### Hash 计算的必要性

分片上传的一个首要目标就是要尽量避免相同的分片重复上传。服务器必须要能够识别来自各个客户端的各个上传请求中，是否存在与过去分片相同的上传请求。

服务器如何识别哪些分片是相同的呢？

首先需要对"相同"下一个准确的定义：**文件内容一样即为相同**。

可是对文件内容进行二进制的对比是一个非常耗时的操作，于是可以选择基于内容的 hash 来进行对比。

> Hash 是一种算法，可以将任何长度的数据转换为定长的数据，常见的 hash 算法包括 MD5、SHA-1。
>
> wf-upload 使用 MD5 进行 hash 计算，使用第三方库 [Spark-MD5](https://github.com/satazor/js-spark-md5)。

不仅针对分片如此，针对整个文件也是如此。

可见，客户端需要承担两件重要的事情：

1. 对文件进行分片，并计算每个分片的 hash 值
2. 根据所有分片的 hash 值，计算整个文件的 hash 值

### Hash 计算的性能问题

计算 Hash 是一件 CPU 密集型的操作，如果不加处理将会导致长时间阻塞主线程。

**传统方案的问题：**
- 需要等待完整文件 Hash 计算完成才能开始上传
- Hash 计算阻塞主线程，导致页面卡顿
- 大文件 Hash 计算耗时很长

### 解决方案：增量 Hash 计算 + 多线程

为了解决这个问题，wf-upload 做了以下优化：

#### 1. 增量 Hash 计算

**核心假设**: 绝大部分的文件上传都是新文件上传。

基于这个假设，我们**无需等待整体 hash 的计算结果，直接上传分片即可**。

**优势：**
- 页面完全无阻塞
- 无需等待整体 hash 即可启动上传
- 对于新文件上传可以缩短整体上传时间

**劣势：**
- 对于旧文件上传可能会产生一些无效的请求
- 但这些请求仅传递的是 hash，并不真实上传文件数据
- 对网络和服务器影响很小，加之旧文件上传情况相对较少，整体影响可以忽略不计

#### 2. 多线程 Hash 计算

使用 **Web Workers** 在后台线程进行 Hash 计算：

- 使用 Worker 线程池并行计算多个分片的 Hash
- 充分利用多核 CPU，大幅提升计算速度
- 完全不阻塞主线程，保证页面流畅

**Hash 计算流程：**

```
文件 → 分片 → Worker 线程池并行计算 Hash → 结果缓冲 → 触发事件
```

**上传流程：**

```
分片 Hash 计算完成 → 检测分片是否存在 → 上传分片（如果不存在）
文件 Hash 计算完成 → 检测文件是否存在 → 秒传（如果存在）
```

## 问题 2: 前后端如何协调？

文件上传涉及到前后端的交互，需要建立一个标准的通信协议。

### 通信协议设计

wf-upload 定义了 4 个核心 API 接口：

1. **创建文件会话** (`POST /file/create`)
2. **Hash 校验** (`POST /file/patchHash`)
3. **分片数据上传** (`POST /file/uploadChunk`)
4. **分片合并** (`POST /file/merge`)

详见 [通信协议文档](./protocol.md)。

### 协议设计原则

1. **简洁明了**: 接口设计简单，易于实现
2. **统一格式**: 所有接口使用统一的请求/响应格式
3. **错误处理**: 完善的错误处理和错误码定义
4. **扩展性**: 支持未来功能扩展

### 上传流程

**正常上传流程：**

```
1. 创建会话 → 获取 token
2. 计算分片 Hash（多线程并行）
3. 检测分片是否存在 → 如果不存在，上传分片
4. 重复步骤 2-3 直到所有分片上传完成
5. 计算文件 Hash（增量计算）
6. 检测文件是否存在 → 如果存在，秒传
7. 合并文件 → 完成上传
```

**秒传流程：**

```
1. 创建会话 → 获取 token
2. 计算文件 Hash
3. 检测文件是否存在 → exists: true
4. 直接完成上传（无需上传分片）
```

**断点续传流程：**

```
1. 创建会话 → 获取 token
2. 计算分片 Hash
3. 检测分片是否存在 → 部分 exists: true，部分 exists: false
4. 仅上传不存在的分片
5. 合并文件 → 完成上传
```

## 架构设计

wf-upload 采用**分层架构**设计：

- **Domain 层**: 核心业务模型和类型定义
- **Infrastructure 层**: HTTP 通信、Worker 线程等技术实现
- **Core 层**: 任务队列、上传队列等核心算法
- **Application 层**: Worker 管理、业务流程编排
- **Presentation 层**: 对外接口、状态管理

详见 [架构设计文档](./architecture.md)。

## 核心特性

### 1. 分片上传

- 将大文件分割成多个小块进行上传
- 支持自定义分片大小
- 支持并发上传

### 2. 断点续传

- 自动检测已上传的分片
- 跳过重复上传
- 支持网络中断后继续上传

### 3. 文件秒传

- 通过文件 Hash 值检测文件是否已存在
- 如果存在，无需上传，直接完成
- 节省带宽和存储空间

### 4. 多线程 Hash 计算

- 使用 Web Workers 线程池并行计算
- 充分利用多核 CPU
- 不阻塞主线程

### 5. 增量 Hash 计算

- 无需等待完整文件 Hash 即可开始上传
- 大幅提升上传速度
- 优化用户体验

## 性能优化

### 1. 并发控制

- 可配置的并发上传数量
- 平衡上传速度和服务器压力
- 避免服务器过载

### 2. 智能重试

- 自动重试失败的分片
- 处理网络错误和超时
- 提高上传成功率

### 3. 结果缓冲

- 缓冲 Hash 计算结果
- 保证事件按顺序触发
- 避免事件乱序

## 总结

wf-upload 通过以下方式解决了大文件上传的问题：

1. ✅ **分片上传**: 将大文件分割成小块，支持断点续传
2. ✅ **Hash 去重**: 基于 Hash 值实现文件去重和秒传
3. ✅ **多线程计算**: 使用 Web Workers 并行计算 Hash，不阻塞主线程
4. ✅ **增量计算**: 无需等待完整 Hash 即可开始上传
5. ✅ **标准化协议**: 定义标准的前后端通信协议
6. ✅ **分层架构**: 清晰的代码结构，易于维护和扩展
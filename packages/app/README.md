# 大文件上传方案
## 背景
企业资料、会议视频等大文件的上传，如果不作特殊处理，将遇到以下问题：

1. 网络中断、程序异常退出等问题导致文件上传失败，从而不得不全部重新上传
2. 同一文件被不同用户反复上传，白白占用网络和服务器存储资源

因此，需要一个针对大文件上传的方案来解决上述问题。

## 问题和方案
大文件上传的普遍方案是文件分片上传。

如果把文件上传看做是一个不可分割的事务，那么分片的目标就是把一个耗时的大事务划分为一个一个的小事务。

分片上传的主要障碍集中在：

1. 如何减少页面阻塞
2. 前后端如何协调
3. 代码如何组织
4. 前端代码中的复杂逻辑

下面分开阐述

### 如何减少页面阻塞？
分片上传的一个首要目标就是要**尽量避免相同的分片重复上传**。服务器必须要能够识别来自各个客户端的各个上传请求中，是否存在与过去分片相同的上传请求。

![](https://resource.duyiedu.com/yuanjin/202403121520874.png)

服务器如何识别哪些分片是相同的呢？

首先需要对相同下一个准确的定义： 文件内容一样即为相同。

可是对文件内容进行二进制的对比是一个非常耗时的操作，于是可以选择基于内容的hash来进行对比。所以 hash 可以用来提升文件内容的对比效率。

> hash是一种算法，可以将任何长度的数据转换为定长的数据，常见的hash算法包括MD5、SHA-1。

![](https://resource.duyiedu.com/yuanjin/202403121531402.png)

不仅针对分片如此，针对整个文件也是如此。

> 为什么需要对整个文件计算 hash，因为可以在上传文件之前对比整个文件的 hash，可以避免不必要的分片上传

![](https://resource.duyiedu.com/yuanjin/202403121537105.png)

可见，客户端需要承担两件重要的事情：

1. 对文件进行分片（分片操作很快就能完成），并计算每个分片的hash值（计算 hash 比较耗时）
2. 根据所有分片的hash值，计算整个文件的hash值（计算 hash 比较耗时）

而计算Hash是一件CPU密集型（计算密集型）的操作，如果不加处理将会导致长时间阻塞主线程。

![](https://resource.duyiedu.com/yuanjin/202403121600216.png)

为了解决这个问题，我们可以对大文件上传做一个大胆的假设：绝大部分的文件上传都是新文件上传。

有了这个假设，我们就无须等待整体hash的计算结果，直接上传分片即可，同时可以把分片操作使用多线程+异步的方式进行上传处理。

![](https://resource.duyiedu.com/yuanjin/202403121608635.png)

> 上图中整体 hash 计算完成时分片的上传还没有完成，此时可与服务器对比整体 hash
>
> 考虑以下三个场景：
>
> 1. 上传一个全新的文件
> 2. 上传一个之前已经上传的文件
> 3. 上传一个之前中断的文件
>

这样做的好处是，页面完全无阻塞，也无须等待整体hash即可启动上传，相比于传统方案：

1. 对于新文件上传可以缩短整体上传时间，消除页面的阻塞。
2. 对于旧文件上传可能会产生一些无效的请求，但这些请求仅传递的是hash，并不真实上传文件数据，所以对网络和服务器影响很小，加之旧文件上传情况相对较少，所以整体影响可以忽略不计。

### 前后端如何协调？
文件上传涉及到前后端的交互，需要建立一个标准的通信协议，通过协议要能完成下面几件核心交互：

> 请求方法、请求头、请求体、相应头、相应体等约定
>

1. 创建文件
2. hash校验
3. 分片数据上传
4. 分片合并

#### 创建文件协议
当客户端发送分片到服务器时，需要告知服务器分片属于哪一次文件上传，因此需要一个唯一标识来标识某一次文件上传。

创建文件协议就是用于获取文件上传的唯一标识。是一个 POST 请求。

```typescript
createFile(file: CreateFile): Promise<{ status: string; token: string }>
```

#### hash校验协议
客户端有时需要校验单个分片或整个文件的hash，服务器需要告知客户端它们目前的具体情况。

```typescript
patchHash<T extends 'file' | 'chunk'>(
    token: string,
    hash: string,
    type: T
  ): Promise<
    T extends 'chunk'
      ? { status: string; hasFile: boolean }
      : { status: string; hasFile: boolean; url: string }
  >
```

#### 分片数据上传协议
通过此协议，上传具体的文件分片数据

```typescript
uploadChunk(config: UploadChunkConfig): Promise<UploadResult>
```

#### 分片合并协议
当所有的分片全部上传后，通过此协议请求服务器完成分片合并。

```typescript
mergeFile(
  token: string,
  hash: string
): Promise<{
  status: string
  url: string
}>
```
